
---
title: "Ensemble Toy Demo"
author: "Tara Eicher"
date: "2/22/2022"
output: rmarkdown::html_document
vignette: >
  %\VignetteIndexEntry{IntLIM:  Integration through Linear Modeling}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---
# Set up.
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
result_dir <- "~\\Ensemble_toy_vignette_results"
dir.create(result_dir)
```

# Install the packages.
```{r eval = FALSE}
if(!require("devtools")){
  install.packages("devtools")
}
library("devtools")
install_github("ncats/MultiOmicsGraphPrediction")
library(EnsemblePrediction)
```

# Import Toy data files.
```{r}
dir <- system.file("extdata", package="MultiOmicsGraphPrediction", mustWork=TRUE)
csvfile <- file.path(dir, "toyinput.csv")
inputData <- IntLIM::ReadData(csvfile)
```

# Run IntLIM
```{r}
myres.gm <- IntLIM::RunIntLim(inputData = inputData,stype="age",
                                 save.covar.pvals = TRUE, 
                                 outcome = 1, 
                                 independent.var.type = 2, 
                                 continuous = TRUE)
saveRDS(myres.gm,file=paste(result_dir, paste0("gm.RData"), sep = "\\"))
```

# Filter Results
```{r}
myres.gm.sig <- IntLIM::ProcessResults(inputResults = myres.gm, inputData = inputData, 
                                       pvalcutoff = 0.20)
IntLIM::OutputResults(inputResults=myres.gm.sig,filename=paste(result_dir,
                                                                    "MyResults.continuous.gm.csv"
                                                                    , sep = "\\"))
```

# Create Co-Regulation Graph
In a co-regulation graph, nodes are analytes (genes and metabolites) and edges indicate
a significant phenotype-dependent association between the analytes.
```{r}
#' Construct a co-regulation graph where nodes are genes and metabolites, and edges
#' are present between nodes and edges that meet the processing cutoffs. Note that
#' the ProcessResults function must be run before BuildCoRegulationGraph is run.
#' This is because the BuildCoRegulationGraph uses the output from ProcessResults
#' to generate the graph. The graph generated by this function is undirected and
#' is an igraph object.
#' @param inputResults A list of IntLimResults objects. Each object must include
#'  model and processing results (output of ProcessResults()).
#' @param vertexSize Width of each vertex in pixels
#' @export
BuildCoRegulationGraph <- function(inputResults, vertexSize=15){
  
  # Set vertex colors.
  color <- "gray"
  framecolor <- "gray"
  
  # Build each data frame.
  graph_df <- BuildGraphDataFrame(inputResults)
  edge_df <- graph_df$edges
  node_df <- graph_df$nodes
  
  # Set parameters.
  node_df <- node_df[!duplicated(node_df$node),]
  node_df$size <- vertexSize
  node_df$color <- color
  node_df$frame.color <- framecolor

  # Build and return the graph.
  final_graph = igraph::graph_from_data_frame(edge_df, vertices = node_df)
  return(final_graph)
}
#' Construct a data frame that includes all information needed to build an igraph
#' object. This includes the names of the two co-regulated analytes, whether the
#' analytes have a positive or negative co-regulation, and the shape of the analytes.
#' @param inputResults A list of data frames. Each object must include
#'  model and processing results (output of ProcessResults()).
BuildGraphDataFrame <- function(inputResults){

  graph_data_frame <- NULL
  if(nrow(inputResults) > 0){
    # Add the analytes to the data frame.
    edge_df = data.frame(from = inputResults[,1], 
                          to = inputResults[,2])
  
    # Add the weights and corresponding colors.
    edge_df$weight = 1
    edge_df$weight[which(inputResults$interaction_coeff < 0)] = -1
    edge_df$color = "blue"
    edge_df$color[which(inputResults$interaction_coeff < 0)] = "red"
  
    # Build the vertex graph, including the shape of each vertex.
    node_df = data.frame(node = unique(inputResults[,1]), 
                            shape = "square")
    second_col_only <- setdiff(inputResults[,2], 
                        inputResults[,1])
    if(length(second_col_only) > 0){
      node_df_c2 = data.frame(node = unique(setdiff(inputResults[,2], 
                                                    inputResults[,1])), 
                              shape = "circle")
      node_df = rbind(node_df, node_df_c2)
    }
    node_df$size = 5
    graph_data_frame <- list(edges = edge_df, nodes = node_df)
  }

  # Return the data frame.
  return(graph_data_frame)
}

# Build graph.
coreg <- BuildCoRegulationGraph(myres.gm.sig)
```

# Run Pairwise Prediction.
```{r}
#' Given each significant pairwise model and the input data, predict the phenotype
#' for each sample. Recall that IntLIM models take the following form:
#' m ~ beta0 + beta1(g) + beta2(phenotype) + beta3(g:phenotype) + beta4...n(covariates)
#' Therefore, to predict phenotype given the betas learned by IntLIM, we use the
#' following model:
#' p ~ (m - (beta0 + beta1(g) + beta4...n(covariates)) / (beta2 + beta3(g))
#' @param inputResults The data frame of filtered results from IntLIM
#'  model and processing results (output of ProcessResults()). All results must
#'  include learned covariate weights (i.e. must be run with save.covar.pvals = TRUE)
#' @param inputData An object with the following fields:
#' @param stype The phenotype (outcome) to predict. This can be either a categorical
#' or numeric outcome.
#' @param covar The clinical covariates to include in the model. These should be the same
#' covariates that were included when running the IntLIM linear models.
#' @param independentVarType The independent variable type (1 or 2)
#' @param outcomeType The outcome type (1 or 2)
#' @export
RunPairwisePrediction <- function(inputResults, inputData, stype=NULL, covar=NULL,
                                  independentVarType = 2, outcomeType = 1){
  
	# Extract data needed for model.
	covariates <- inputData@sampleMetaData
	independent.vars <- NULL
	dependent.vars <- NULL
	independent.vars <- as.data.frame(inputData@analyteType1)
	if(independentVarType == 2){
	  independent.vars <- as.data.frame(inputData@analyteType2)
	}
	dependent.vars <- as.data.frame(inputData@analyteType1)
	if(outcomeType == 2){
	  dependent.vars <- as.data.frame(inputData@analyteType2)
	}

	# Extract coefficients.
	which_start <- which(colnames(inputResults) == "rsquared")[1]
	if(is.na(which_start)){
	  which_start <- which(colnames(inputResults) == "FDRadjPval")[1]
	}
	which_start <- which_start + 1
	coefficients <- inputResults[,c(1:2)]
	if(which_start <= (ncol(inputResults))){
	  coefficients <- inputResults[,c(1:2, which_start:(ncol(inputResults)))]
	}
	coefficients$Analyte1 <- as.character(coefficients$Analyte1)
	coefficients$Analyte2 <- as.character(coefficients$Analyte2)
	which_interact <- which(grepl(":", colnames(coefficients)) == TRUE)

	# Construct matrix of coefficients.
	intercept <- matrix(coefficients[,"(Intercept)"], 
						nrow=length(coefficients[,"(Intercept)"]), 
						ncol=ncol(independent.vars))
	ind_var <- matrix(coefficients$a, 
					  nrow=length(coefficients$a), 
					  ncol=ncol(independent.vars))
	interact_var <- matrix(coefficients[,which_interact], 
						   nrow=length(coefficients[,which_interact]), 
						   ncol=ncol(independent.vars))
	phen_var <- matrix(coefficients$type, nrow=length(coefficients$type), 
					   ncol=ncol(independent.vars))

	# Compute the numerator of the prediction for each subject 
	# (sans covariate terms)
	ind_term <- independent.vars[coefficients$Analyte1,] * ind_var
	dep_term <- dependent.vars[coefficients$Analyte2,]
	pred_phenotype <- dep_term - (intercept + ind_term)

	# If there are covariates, include the covariate terms in the prediction
	# by subtracting them.
	if(!is.null(covar)) {
	  all_cov_terms<- lapply(covar, function(cov_name){
		coef_cov_name <- colnames(coefficients)[grepl(cov_name, colnames(coefficients))]
		cov_cov_name <- colnames(covariates)[grepl(cov_name, colnames(covariates))]
		this_covariate_term <- NULL
		
		# If the term is numeric, simply multiply.
		if(is.numeric(covariates[,cov_cov_name])){
		  this_coefficient_mat <- matrix(coefficients[,coef_cov_name], 
										 nrow=length(coefficients[,coef_cov_name]), 
										 ncol=dim(covariates)[1])
		  this_covariate_mat <- t(matrix(covariates[,cov_cov_name], 
										 ncol=length(coefficients[,coef_cov_name]), 
										 nrow=dim(covariates)[1]))
		  this_covariate_term <- this_coefficient_mat * this_covariate_mat
		}
		else if(length(coef_cov_name) == 1){
		  second_part_of_name <- strsplit(coef_cov_name, cov_name)[[1]][2]
		  this_covariate_term <- multiplyCovariate(coefficients, covariates, coef_cov_name, 
												   cov_cov_name, second_part_of_name)
		}
		# Add together the multiples of the one-hot-encoded terms.
		else{
		  these_covariate_terms <-lapply(1:length(coef_cov_name), function(i){
			second_part_of_name <- strsplit(coef_cov_name[i], cov_name)[[1]][2]
			cova <- covariates
			for(j in 1:dim(cova)[2]){
			  cova[,j] <- as.character(cova[,j])
			}
			cova[multi.which(cova != second_part_of_name)] <- "Other"
			current_covariate_term <- multiplyCovariate(coefficients, cova, coef_cov_name[i], 
														cov_cov_name, second_part_of_name)
			return(current_covariate_term)
		  })
		  this_covariate_term <- Reduce('+', these_covariate_terms)
		}
		return(this_covariate_term)
	  })
	  
	  # Include the covariates in the numerator prediction.
	  final_covariate_val <- Reduce('+', all_cov_terms)
	  pred_phenotype <- pred_phenotype - final_covariate_val
	}

	# Calculate the denominator and divide.
	div_term <- independent.vars[coefficients$Analyte1,] * interact_var
	div_term <- div_term + phen_var
	pred_phenotype <- pred_phenotype / div_term 

	# For discrete phenotypes only, round the value.
	if(!is.numeric(inputData@sampleMetaData[,stype])){
	  pred_phenotype[multi.which(pred_phenotype >= 1)] <- 1
	  pred_phenotype[multi.which(pred_phenotype <= 0)] <- 0
	  pred_phenotype <- round(pred_phenotype,digits=0)
	}
	pred_phenotype = as.data.frame(pred_phenotype)

	# Add analyte information for each prediction.
	pred_phenotype$to <- coefficients$Analyte2
	pred_phenotype$from <- coefficients$Analyte1
	return(pred_phenotype)
}

# Run pairwise prediction.
pred <- RunPairwisePrediction(inputResults = myres.gm.sig, inputData = inputData,
                              stype = "age")
```

# Plot Graph
## Project Predictions
```{r plot graph}
#' Given a graph and a phenotype prediction for each significant pair, generate a 
#' new graph with the phenotype predictions included as the edge weights.
#' @param predictions A matrix of predictions. Each signficant pair of analytes 
#' results in a prediction for each subject.
#' @param coRegulationGraph An igraph object. This graph is the co-regulation graph
#' generated using IntLIM analysis of analyte pairs.
#' @export
ProjectPredictionsOntoGraph <- function(predictions, coRegulationGraph){
  
  # Convert graph into data frame.
  edges <- igraph::as_data_frame(coRegulationGraph, what = "edges")
  
  # Define continuous color based on prediction.
  pal <- grDevices::colorRampPalette(c("limegreen", "purple"))

  # Modify n copies of graph, where n is the number of subjects.
  new_graphs <- lapply(1:(dim(predictions)[2]-2), function(i){

    # Modify graph weight.
    subject_graph <- data.frame(edges)
    subject_graph$weight <- predictions[,i]
    
    # Modify color.
    bin_count <- 100
    preds <- predictions[,i][which(!is.na(predictions[,i]))]
    intervals <- seq(range(preds)[1], range(preds)[2], 
                     by = (range(preds)[2] - range(preds)[1])
                     / (bin_count - 1))
    subject_color_scale <- rep(NA, length(predictions[,i]))
    subject_color_scale[which(!is.na(predictions[,i]))] <- 
      findInterval(preds, intervals)
    subject_graph$color <- pal(bin_count + 1)[subject_color_scale]

    # Modify node properties.
    node_df <- igraph::as_data_frame(coRegulationGraph, what = "vertices")
    
    # Create graph.
    final_graph = igraph::graph_from_data_frame(subject_graph, vertices = node_df)
    return(final_graph)
  })
  names(new_graphs)<-colnames(predictions)[1:(length(colnames(predictions))-2)]
  return(new_graphs)
}

# Project graph.
projectedGraph <- ProjectPredictionsOntoGraph(coRegulationGraph = coreg, predictions = pred)
```

## Create Model Input
```{r model input}
#' ModelInput class
#'
#' @name ModelInput-class
#' @rdname ModelInput-class
#' @exportClass ModelInput
#' @slot A.hat The Laplacian of a line graph built from the co-regulation graphs, where 
#' each node corresponds to a pair of analytes.
#' @slot node.wise.prediction graph of co-regulation results from IntLIM
#' @slot true.phenotypes data frame of true phenotypes given analyte pairs
#' and clinical covariates
#' @slot outcome.type "numeric" or "categorical"
#' @slot coregulation.graph the original co-regulation graph for the input data.
#' @slot line.graph the line graph of the input data.
methods::setClass(
  Class="ModelInput",
  representation(A.hat="matrix",
                 node.wise.prediction="matrix",
                 true.phenotypes="numeric",
                 coregulation.graph="matrix",
                 line.graph="matrix",
                 outcome.type="character",
                 modified.outliers="list")
)
#' Create a line graph given the original, unweighted graph. In a line graph,
#' edges are nodes, and edges connected by a node are edges.
#' @param predictionsByEdge Prediction levels corresponding to each edge.
#' @param graphWithPredictions Original graph data frame.
#' @param edgeTypeList List containing one or more of the following:
#' - "shared.outcome.analyte"
#' - "shared.independent.analyte"
#' - "analyte.chain"
CreateLineGraph <- function(predictionsByEdge, graphWithPredictions, edgeTypeList){
  # Step 1: Define vertices.
  line_graph_vertices <- predictionsByEdge$Node
  list_to_add <- list()
  
  # Step 2: Identify edges that share "to" nodes.
  if("shared.outcome.analyte" %in% edgeTypeList){
    list_to_add[[length(list_to_add)+1]] <- FindEdgesSharingNodes(predictionsByEdge = predictionsByEdge,
                                                                  graphWithPredictions = graphWithPredictions,
                                                                  nodeType1 = "to", nodeType2 = "to")
  }
  
  # Step 3: Identify edges that share "from" nodes.
  if("shared.independent.analyte" %in% edgeTypeList){
    list_to_add[[length(list_to_add)+1]] <- FindEdgesSharingNodes(predictionsByEdge = predictionsByEdge,
                                                                  graphWithPredictions = graphWithPredictions,
                                                                  nodeType1 = "from", nodeType2 = "from")
  }
  
  # Step 4: For each "to" node, identify edges that share a "from" node.
  if("analyte.chain" %in% edgeTypeList){
    list_to_add[[length(list_to_add)+1]] <- FindEdgesSharingNodes(predictionsByEdge = predictionsByEdge,
                                                                  graphWithPredictions = graphWithPredictions,
                                                                  nodeType1 = "to", nodeType2 = "from")
  }
  
  # Step 6: Concatenate.
  shared_df <- list_to_add[[1]]
  if(length(list_to_add) > 1){
    shared_df <- do.call(rbind, list_to_add)
  }
  
  # Step 7: Convert to graph.
  line_graph <- igraph::graph_from_data_frame(shared_df)
  
  # Step 8: Convert to adjacency matrix.
  line_graph_A <- igraph::as_adj(line_graph)
  
  # Return.
  return(line_graph_A)
}
#' Find edges that share nodes and add them to a data frame.
#' @param predictionsByEdge Prediction levels corresponding to each edge.
#' @param graphWithPredictions Original graph data frame.
#' @param nodeType1 Either "to" or "from".
#' @param nodeType2 Either "to or "from".
FindEdgesSharingNodes <- function(predictionsByEdge, graphWithPredictions, nodeType1,
                                  nodeType2){
  # Convert predictions to data frame.
  graph_df <- igraph::as_data_frame(graphWithPredictions)
  
  # Find shared nodes.
  nodes <- unique(graph_df[,nodeType1])
  to_shared <- lapply(1:length(nodes), function(i){
    
    # Find all line graph nodes starting with or ending with the analyte in question.
    node <- nodes[i]
    combs <- NULL
    set_with_1 <- predictionsByEdge$Node[which(graph_df[,nodeType1] == node)]
    set_with_2 <- predictionsByEdge$Node[which(graph_df[,nodeType2] == node)]
    
    # If there are multiple line graph nodes including this analyte, return them.
    combs <- expand.grid(set_with_1, set_with_2)
    combs$Var1 <- as.character(combs$Var1)
    combs$Var2 <- as.character(combs$Var2)
    combs <- combs[which(combs$Var1 != combs$Var2),]
    colnames(combs) <- c("to", "from")
    return(combs)
  })
  
  # Concatenate all shared nodes.
  line_graph_df <- do.call(rbind, to_shared)
  
  return(line_graph_df)
}
#' 
#' Format the input for graph-based learning. This input consists of:
#' 1. The Laplacian of a line graph built from the co-regulation graphs, where 
#' each node corresponds to a pair of analytes.
#' 2. A prediction value for each node of the line graph, for each sample X.
#' 3. The true prediction values Y for each sample X.
#' @include internalfunctions.R
#' @param inputData MultiDataSet object (output of ReadData()) with gene expression,
#' metabolite abundances, and associated meta-data
#' @param predictionGraphs A list of igraph objects, each of which includes
#' predictions for each edge.
#' @param coregulationGraph An igraph object containing the coregulation graph.
#' @param stype.class The class of the outcome ("numeric" or "categorical")
#' @param stype The phenotype or outcome of interest
#' @param edgeTypeList List containing one or more of the following to include
#' in the line graph:
#' - "shared.outcome.analyte"
#' - "shared.independent.analyte"
#' - "analyte.chain"
#' @param verbose Whether to print the number of predictions replaced in each sample.
#' TRUE or FALSE. Default is FALSE.
#' @export
FormatInput <- function(predictionGraphs, coregulationGraph,
                   inputData, stype.class, edgeTypeList, stype, verbose = FALSE){
  
  # Extract edge-wise predictions.
  predictions_by_node <- lapply(names(predictionGraphs), function(sampName){
    df_predictions <- igraph::as_data_frame(predictionGraphs[[sampName]])
    node_names <- paste(make.names(df_predictions$to), make.names(df_predictions$from),
                        sep = "__")
    df_predictions_new <- data.frame(Node = node_names, Weight = df_predictions$weight)
    return(df_predictions_new)
  })
  names(predictions_by_node) <- names(predictionGraphs)
  predicted_weights_only <- lapply(predictions_by_node, function(pred){
    return(pred$Weight)
  })
  predictions_flattened <- t(data.frame(predicted_weights_only))
  colnames(predictions_flattened) <- predictions_by_node[[1]]$Node
  
  # Convert co-regulation graph into a line graph. Return the adjacency matrix.
  # If edges were not connected by nodes in the original graph, they may be
  # removed from the line graph. Remove these from the predictions_by_node df.
  A <- CreateLineGraph(predictionsByEdge = predictions_by_node[[1]],
                       graphWithPredictions = predictionGraphs[[1]],
                       edgeTypeList = edgeTypeList)
  predictions_flattened <- predictions_flattened[,colnames(A)]
  predictions_flattened_orig <- predictions_flattened

  # Add self-loops.
  A_tilde <- as.matrix(A)
  diag(A_tilde) <- 1
  
  # Extract the diagonal (in degree) and raise to the negative half power.
  diags1 <- colSums(A_tilde)
  diags_neg_half <- 1 / sqrt(diags1)
  D_tilde_neg_half1 <- t(matrix(rep(diags_neg_half,length(diags_neg_half)),
                                nrow = length(diags_neg_half)))
  A_hat1 <- D_tilde_neg_half1 * A_tilde
  rm(D_tilde_neg_half1)
  
  # Extract the diagonal (out degree) and raise to the negative half power.
  diags2 <- rowSums(A_tilde)
  rm(A_tilde)
  diags_neg_half <- 1 / sqrt(diags2)
  D_tilde_neg_half2 <- t(matrix(rep(diags_neg_half,length(diags_neg_half)),
                                nrow = length(diags_neg_half)))
  
  # Obtain the final matrix. Note that we modify the matrix multiplication
  # problem to obtain an elementwise multiplication problem
  # because it speeds up computation.
  A_hat <- A_hat1 * D_tilde_neg_half2
  
  # Obtain the predictions.
  Y <- inputData@sampleMetaData[,stype]
  if(stype.class == "factor"){
    Y <- as.numeric(Y)-1
  }
  names(Y) <- names(predictions_by_node)
  
  # Create a ModelInput object and return it.
  newModelInput <- methods::new("ModelInput", A.hat=A_hat, node.wise.prediction=t(predictions_flattened),
                                true.phenotypes=Y, outcome.type=stype.class, 
                                coregulation.graph=igraph::get.adjacency(coregulationGraph, sparse = FALSE), 
                                line.graph=as.matrix(A), modified.outliers=list())
  return(newModelInput)
}

# Create input.
modelInput <- FormatInput(predictionGraphs = projectedGraph, coregulationGraph = coreg,
                   inputData = inputData, stype.class = "numeric", stype = "age",
                   edgeTypeList = c("shared.outcome.analyte", "shared.independent.analyte"))
saveRDS(modelInput,file=paste(result_dir, paste0("modelInput.RDS"), sep = "\\"))
```

## Plot
```{r plot line graph}
#' Plot the line graph for each sample with nodes colored according to prediction.
#' Include a color scale for the predictions.
#' @param modelInput A list of ModelInput objects.
#' @param saveInDir Directory where file should be saved. If NULL, then the output
#' is plotted without being saved. Default is NULL.
#' @param stype Outcome / phenotype
#' @param analytes List of vectors of analytes to plot. This is used if one
#' wishes to focus on a subset of analytes If NULL, then all vertices are plotted.
#' Default is NULL.
#' @param truncateTo Analyte names are truncated to the first "truncateTo" characters.
#' Default is 4. If NULL, names are not truncated.
#' @param weights The weight assigned to each node. This is encoded using opacity.
#' If NULL, all nodes are opaque. Default is NULL.
#' @param analytes analytes of interest. Default is NULL
#' @param includeLabels whether or not to include labels. Defaults to TRUE.
#' @param cutoffs Cutoff weight values, which can be included for visibility.
#' Default is NULL.
#' @param vertexSize Vertex size to use in display.
#' @export
PlotLineGraph <- function(modelInput, stype, saveInDir = NULL,
                          truncateTo = 2, titleStart = NULL, weights = NULL,
                          analytes = NULL, includeLabels = TRUE, cutoffs = NULL,
                          vertexSize = 10){
  # Extract graph and predictions.
  line.graph <- modelInput@line.graph
  node.wise.prediction <- modelInput@node.wise.prediction
  Y <- modelInput@true.phenotypes
  if(length(unique(Y)) == 2 && min(Y) == 1){
    Y <- Y - 1
  }
  
  for(j in 1:dim(node.wise.prediction)[2]){
    
    # Build node and edge graphs.
    edge_df <- reshape2::melt(line.graph)
    edge_df <- edge_df[which(edge_df[,3] != 0),]
    edge_df$arrow.size <- 0.25
    color <- "black"
    node_df <- data.frame(names(node.wise.prediction[,j]), node.wise.prediction[,j],
                          color)
    rownames(node_df) <- names(node.wise.prediction[,j])
    colnames(node_df) <- c("name", "prediction", "color")
    node_df$frame.color <- color
    final_graph <- igraph::graph_from_data_frame(edge_df, vertices = node_df)
    
    # Filter graph if required.
    wt <- node.wise.prediction[,j]
    if(!is.null(analytes)){
      
      vertices_with_analytes <- unlist(lapply(analytes, function(a){
        return(igraph::V(final_graph)$name[grepl(a, igraph::V(final_graph)$name,
                                                 fixed = TRUE)])
      }))
      final_graph <- igraph::induced_subgraph(final_graph, vertices_with_analytes)
      wt <- node.wise.prediction[names(igraph::V(final_graph)),j]
    }
    wt[which(wt<cutoffs[1])]<-cutoffs[1]
    wt[which(wt>cutoffs[2])]<-cutoffs[2]
    
    # Set up node colors.
    bin_count <- 100
    # Make sure the spacing is even. We need to do this using seq.
    intervals <- seq(range(wt)[1], range(wt)[2],
                     by = (range(wt)[2] - range(wt)[1]) / (bin_count - 1))
    subject_color_scale <- findInterval(wt, intervals)
    pal <- grDevices::colorRampPalette(c("limegreen", "purple"))(bin_count+1)
    color <-pal[subject_color_scale]
    
    # Adjust color opacity.
    if(!is.null(weights)){
      opacity <- abs(weights) / max(abs(weights))
      color <- unlist(lapply(1:length(color), function(c){
        return(grDevices::adjustcolor(color[c], alpha.f = opacity[c]))
      }))
    }
    igraph::V(final_graph)$color <- color
    
    # Set up variables for plotting.
    title <- paste(colnames(node.wise.prediction)[j],
                   paste("True Outcome =", formatC(Y[j], digits = 2, format = "f")),
                   sep = "\n")
    minPred <- min(unname(wt))
    maxPred <- max(unname(wt))
    ticks <- seq(minPred, maxPred, len=11)
    scale <- (length(pal)-1)/(maxPred-minPred)
    colorBarTitle <- "Prediction"
    
    # Plot.
    graph_labels <- NA
    if(includeLabels == TRUE){
      graph_labels <- unlist(lapply(igraph::V(final_graph)$name, function(v){
        pieces <- strsplit(v, "__")[[1]]
        sub_from <- pieces[1]
        sub_to <- pieces[2]
        if(!is.null(truncateTo)){
          sub_from <- substr(pieces[1], 1, truncateTo)
          sub_to <- substr(pieces[2], 1, truncateTo)
        }
        return(paste(sub_from, sub_to, sep = "_"))
      }))
    }
    
    par(mfrow=c(1,2))
    plot(final_graph, main = title, vertex.label = graph_labels, vertex.size = vertexSize)
    plot(c(0,10), c(minPred,maxPred), type='n', bty='n', xaxt='n', xlab='', yaxt='n', ylab='')
    title(colorBarTitle, adj = 0, cex.main = 0.75)
    graphics::axis(2, ticks, las=1)
    for (l in 1:(length(pal)-1)) {
      y <- (l-1)/scale + minPred
      graphics::rect(0,y,1,y+1/scale, col=pal[l], border=NA)
    }
  }
}
PlotLineGraph(modelInput = modelInput, stype = "age", cutoffs = c(0,100),
              truncateTo = NULL)
```