#' Construct a co-regulation graph where nodes are genes and metabolites, and edges
#' are present between nodes and edges that meet the processing cutoffs. Note that
#' the ProcessResults function must be run before BuildCoRegulationGraph is run.
#' This is because the BuildCoRegulationGraph uses the output from ProcessResults
#' to generate the graph. The graph generated by this function is undirected and
#' is an igraph object.
#' @param inputResults A list of IntLimResults objects. Each object must include
#'  model and processing results (output of ProcessResults()).
#' @param vertexSize Width of each vertex in pixels
#' @export
BuildCoRegulationGraph <- function(inputResults, vertexSize=15){
  
  # Set vertex colors.
  color <- "gray"
  framecolor <- "gray"
  
  # Build each data frame.
  graph_df <- BuildGraphDataFrame(inputResults)
  edge_df <- graph_df$edges
  node_df <- graph_df$nodes
  
  # Set parameters.
  node_df <- node_df[!duplicated(node_df$node),]
  node_df$size <- vertexSize
  node_df$color <- color
  node_df$frame.color <- framecolor
  
  # Build and return the graph.
  final_graph = igraph::graph_from_data_frame(edge_df, vertices = node_df)
  return(final_graph)
}

#' Construct a data frame that includes all information needed to build an igraph
#' object. This includes the names of the two co-regulated analytes, whether the
#' analytes have a positive or negative co-regulation, and the shape of the analytes.
#' @param inputResults A list of data frames. Each object must include
#'  model and processing results (output of ProcessResults()).
BuildGraphDataFrame <- function(inputResults){
  
  graph_data_frame <- NULL
  if(nrow(inputResults) > 0){
    # Add the analytes to the data frame.
    edge_df = data.frame(from = inputResults[,1], 
                         to = inputResults[,2])
    
    # Add the weights and corresponding colors.
    edge_df$weight = 1
    edge_df$weight[which(inputResults$interaction_coeff < 0)] = -1
    edge_df$color = "blue"
    edge_df$color[which(inputResults$interaction_coeff < 0)] = "red"
    
    # Build the vertex graph, including the shape of each vertex.
    node_df = data.frame(node = unique(inputResults[,1]), 
                         shape = "square")
    second_col_only <- setdiff(inputResults[,2], 
                               inputResults[,1])
    if(length(second_col_only) > 0){
      node_df_c2 = data.frame(node = unique(setdiff(inputResults[,2], 
                                                    inputResults[,1])), 
                              shape = "circle")
      node_df = rbind(node_df, node_df_c2)
    }
    node_df$size = 5
    graph_data_frame <- list(edges = edge_df, nodes = node_df)
  }
  
  # Return the data frame.
  return(graph_data_frame)
}

#' Return each analyte in the graph ranked by hub score. The analytes at the top
#' of the data frame are the hubs. 
#' @param coRegulationGraph An igraph object. This graph is the co-regulation graph
#' generated using IntLIM analysis of analyte pairs.
#' @param hubMetric Can take one of four values:
#' 1. "betweenness": the betweenness centrality (i.e. the percent of all paths in the
#' graph that pass through a node).
#' 2. "kleinberg": the square of the adjacency matrix. This measures the connectivity
#' of the node.
#' 3. "closeness": the average shortest path from a node to all other nodes.
#' 4. "eccentricity": the maximum distance from a node to all other nodes.
#' @export
ComputeCentrality <- function(coRegulationGraph, hubMetric){
  centrality = data.frame(Analyte = sort(igraph::as_ids(igraph::V(coRegulationGraph))))
  if("betweenness" %in% hubMetric){
    btwn <- igraph::betweenness(coRegulationGraph, 
                                   weights = rep(1:length(igraph::E(coRegulationGraph))),
                                directed = FALSE)
    centrality$Betweenness <- btwn[order(names(btwn))]
  }
  if("kleinberg" %in% hubMetric){
    klein <- igraph::hub.score(coRegulationGraph,
                            weights = rep(1:length(igraph::E(coRegulationGraph))))$vector
    centrality$Kleinberg <- klein[order(names(klein))]
  }
  if("closeness" %in% hubMetric){
    close <- igraph::estimate_closeness(coRegulationGraph, cutoff = 0,
                                          weights = rep(1:length(igraph::E(coRegulationGraph))))
    centrality$Closeness <- close[order(names(close))]
  }
  if("eccentricity" %in% hubMetric){
    ecc <- igraph::eccentricity(coRegulationGraph)
    centrality$Eccentricity <- ecc[order(names(ecc))]
  }
  extras <- setdiff(hubMetric, list("betweenness", "kleinberg", "closeness", 
                                    "eccentricity"))
  if(length(extras) > 0){
    print("The following are not accepted centrality metrics:")
    print(extras)
  }
  if(length(centrality) == 0){
    stop("No valid centrality metrics provided.")
  }
  rownames(centrality) = centrality$Analyte
  centrality$Analyte = NULL
  return(centrality)
}

#' Construct a co-regulation graph for each fold.
#' @param inputResults A list of data frames. Each data frame consists of the
#' filt.results slot from an IntLIMResults object.
#' @param independentVarType The independent variable type ("gene" or "metabolite")
#' @param outcome The outcome type ("gene" or "metabolite")
#' @param vertexSize Width of each vertex in pixels
#' @export
BuildCoRegulationGraphAllFolds <- function(inputResults, vertexSize=15,
                                           independentVarType, outcome){
  # If there are multiple types of graphs being used, rearrange the graphs.
  if(length(independentVarType) > 1){
    inputResults <- lapply(1:length(inputResults[[1]]), function(i){
      return(lapply(1:length(inputResults), function(j){
        return(inputResults[[j]][[i]])
      }))
    })
  }
  graphs <- lapply(1:length(inputResults), function(i){
    return(BuildCoRegulationGraph(inputResults = inputResults[[i]]))
  })
  
  # Assign names.
  names(graphs) <- unlist(lapply(1:length(inputResults), function(i){
    return(paste("Fold", i, sep = "_"))
  }))
  return(graphs)
}